Trabalho Pr√°tico 3
Compacta√ß√£o de Arquivos de Texto

Lucas Albano Olive Cruz ‚Äì 2022036209

Departamento de Ci√™ncia da Computa√ß√£o (DCC) - Universidade Federal de Minas Gerais (UFMG)
Belo Horizonte - MG ‚Äì Brasil

lucasalbano@dcc.ufmg.br


1. Introdu√ß√£o
O problema proposto consiste em ajudar uma empresa de jornais a reduzir gastos com armazenamento de edi√ß√µes passadas do jornal. Assim, prop√µe-se utilizar o algoritmo de Huffman para compactar arquivos de texto. Dessa forma, o programa deve receber dois arquivos: um .txt com o conte√∫do a ser compactado e um arquivo que ap√≥s os passos do algoritmo possuir√° o texto compactado.
A sequ√™ncia de passos do programa proposto come√ßa percorrendo todo o arquivo e registrando a frequ√™ncia de cada caractere. Em seguida, criamos uma fila de prioridade m√≠nima chaveada pela frequ√™ncia de cada caractere. Com a fila de prioridade, montamos uma √°rvore que cont√™m em suas folhas os caracteres e suas frequ√™ncias e a partir desta conseguimos construir uma tabela de codifica√ß√£o e ent√£o efetivamente come√ßar a compacta√ß√£o do arquivo. Assim, percorremos novamente o arquivo e para cada caractere consultamos a tabela e registramos no arquivo de sa√≠da a sequ√™ncia de bits correspondente. Armazenamos no cabe√ßalho do arquivo compactado a √°rvore utilizada para na etapa de descompacta√ß√£o remont√°-la e partir do caminhamento na √°rvore recuperar o texto original.


2. M√©todo
Alguns TADs foram necess√°rios para a resolu√ß√£o do problema, assim como o uso de algoritmos como o algoritmo de Huffman. Nesta se√ß√£o irei descrever as estruturas de dados utilizadas assim como os algoritmos e procedimentos necess√°rios para a compacta√ß√£o e descompacta√ß√£o do arquivo de texto.
2.1. Estruturas de Dados
Ao todo precisamos utilizar tr√™s estruturas de dados auxiliares para realizar os passos do programa. Como veremos a seguir, somente com um tipo de n√≥ conseguimos utilizar as tr√™s estruturas, sendo estas: √Årvore, Fila de Prioridade e Pilha.

2.1.1. Node
Dessa maneira, nosso n√≥ √© a estrutura elementar do nosso programa, a partir dele constru√≠mos todas as demais estruturas. A classe node possui cinco atributos: um tipo char que armazena o caractere, um tipo int que armazena a frequ√™ncia do caractere e tr√™s ponteiros para n√≥s left, right e next. Os dois primeiros ponteiros s√£o utilizados pela √°rvore e o √∫ltimo pela fila e pilha.
As fun√ß√µes s√£o apenas getters e setters para estes atributos. Possui tr√™s construtores, um padr√£o quando nenhum par√¢metro √© fornecido que inicia todos os ponteiros como nullptr a frequ√™ncia como zero e o caractere como nulo (‚Äò\0‚Äô). Um construtor com par√¢metros para o caractere e a frequ√™ncia o qual inicia estes atributos conforme fornecidos e os ponteiros como nulo. Por fim, um construtor com dois outros n√≥s como par√¢metro que inicia o caractere como nulo, a frequ√™ncia como a soma das frequ√™ncias dos dois n√≥s, o ponteiro para esquerda como o primeiro e o ponteiro para a direita como o segundo n√≥ fornecido. Este √∫ltimo construtor ir√° nos auxiliar ao executar o algoritmo de Huffman descrito na Se√ß√£o 2.2.1. O ponteiro next √© inicializado como nullptr em todos os casos.

2.1.2. Tree
A classe √°rvore segue a estrutura usual de uma √°rvore bin√°ria, por√©m esta n√£o √© balanceada. Possui apenas um ponteiro para a raiz da √°rvore e fun√ß√µes simples getters e setters, construtor, destrutor, uma fun√ß√£o para verificar se est√° vazia, limpar a √°rvore e medir sua altura. 
A parte mais importante da classe est√° na fun√ß√£o build que constr√≥i a √°rvore a partir de uma fila de prioridade ou de uma pilha. A fila de prioridade √© utilizada na compacta√ß√£o do arquivo e a constru√ß√£o da √°rvore a partir desta ser√° explicada na se√ß√£o 2.2.1. A pilha √© utilizada quando queremos descompactar o arquivo e similarmente ser√° explicada na se√ß√£o 2.2.4.

2.1.3. Queue
Nossa classe fila √© basicamente uma lista encadeada simples que √© ordenada em ordem crescente pelo atributo frequ√™ncia de cada n√≥. Assim, a classe possui um ponteiro para o primeiro elemento que chamamos de head e um atributo size que representa o tamanho atual da fila de prioridade m√≠nima.
Al√©m dos tradicionais construtores, destrutores, getters e setters as fun√ß√µes mais significantes da classe s√£o push respons√°vel por adicionar um elemento na fila e pop respons√°vel por remover um elemento.
A fun√ß√£o de inser√ß√£o possui tr√™s casos. O primeiro √© de que a fila est√° vazia, neste caso o elemento √© inserido como o head. No caso de a fila n√£o estar vazia, por√©m o elemento a ser inserido possuir frequ√™ncia menor que o head ele passa a apontar para o head e se torna o novo head da fila. O √∫ltimo caso acontece quando n√£o estamos em nenhum dos casos anteriores ent√£o buscamos o local da fila que o elemento deve ser inserido. Ao encontramos a posi√ß√£o o elemento imediatamente anterior passa a apontar ao elemento que est√° sendo inserido e este aponta para o elemento posterior. Em qualquer um dos tr√™s casos, ap√≥s a inser√ß√£o adicionamos um ao tamanho da fila.
Como a inser√ß√£o √© feita de forma ordenada, a fun√ß√£o pop somente retorna o head que j√° ser√° o elemento com a menor frequ√™ncia da fila e assim torna o elemento imediatamente posterior a este o novo head da fila. Ap√≥s a remo√ß√£o o tamanho da fila decresce em um.

2.1.4. Stack
A classe pilha ser√° usada para remontar a √°rvore na fase de descompacta√ß√£o. Esta segue as funcionalidades j√° conhecidas de uma pilha, assim possui somente dois atributos similares a fila: um elemento que representa o topo da pilha identificado por top e um atributo size para representar o tamanho da pilha.
Novamente, fun√ß√µes getters, setters, construtor e destrutor. A fun√ß√£o push somente adiciona um novo n√≥ ao topo da pilha e a fun√ß√£o pop remove o topo da pilha, ambos atualizam o atributo size.

2.2. Algoritmos
Os algoritmos utilizados no programa manipulam as estruturas de dados anteriormente descritas com a finalidade de transformar um arquivo de entrada em um arquivo compactado e vice-versa. Assim, nesta se√ß√£o irei descrever a utiliza√ß√£o do algoritmo de Huffman e como se segue o passo-a-passo para compactar ou descompactar um arquivo de texto.

2.2.1. Algoritmo de Huffman
Para compactarmos um arquivo precisamos reduzir o tamanho da representa√ß√£o de cada caractere, portanto, um caractere que √© representado por um byte passaria a ser representado por exemplo por somente dois ou tr√™s bits. O algoritmo de Huffman funciona definindo uma nova representa√ß√£o para um caractere de tamanho em bits vari√°vel a depender de sua frequ√™ncia em determinado texto.
A nova codifica√ß√£o do caractere √© definida pelo caminho necess√°rio para chegar at√© este em uma √°rvore. Dessa forma, os caracteres sempre estar√£o nas folhas da √°rvore e a quantidade de passos para a esquerda ou para a direita, representados por 0 e 1 respectivamente, tomados na √°rvore definem a sequ√™ncia de bits que representa o caractere.
O algoritmo constr√≥i a √°rvore recebendo como entrada uma fila de prioridade m√≠nima ordenada pela frequ√™ncia do caractere, descrita na se√ß√£o 2.1.3. Assim, removemos os dois primeiros elementos da fila que possuir√£o as duas menores frequ√™ncias e formamos um novo n√≥ com frequ√™ncia igual a soma das frequ√™ncias dos dois n√≥s removidos e o inserimos novamente na fila. Esse processo continua at√© possuirmos somente um n√≥ na fila que ser√° ent√£o a raiz de nossa √°rvore. Um exemplo da execu√ß√£o do algoritmo pode ser visto na Figura 1.

Figura 1 ‚Äì Passos do algoritmo de Huffman. Retirado de Introduction to Algorithms.

2.2.2. Tabela de Codifica√ß√£o
Para compactarmos nosso arquivo precisamos encontrar a nova representa√ß√£o de um caractere sempre que o identificarmos no arquivo. Tentar toda vez encontrar essa representa√ß√£o caminhando pela √°rvore √© bastante custoso, ent√£o utilizamos uma tabela de codifica√ß√£o para armazenar a sequ√™ncia de bits que representa o caractere.
Esta tabela √© uma matriz em que cada linha √© a codifica√ß√£o de um caractere. Ela possui 256 linhas que s√£o a quantidade de chars em C++. O tamanho de cada linha, ou o n√∫mero de colunas, √© a altura da √°rvore + 1 pois este n√∫mero √© a maior nova codifica√ß√£o de um caractere mais uma coluna para representar o fim da codifica√ß√£o.
Dessa forma, a tabela √© constru√≠da ao percorrer toda a √°rvore e enquanto percorremos registramos 0 para cada passo a esquerda e 1 para cada passo a direita. Ao chegarmos em uma folha registramos na tabela o caminho obtido na posi√ß√£o correspondente ao caractere guardado na folha.

2.2.3. Compacta√ß√£o
A fun√ß√£o de compacta√ß√£o recebe dois arquivos, o que deve ser compactado (input) e o que recebera o resultado da compacta√ß√£o (output). O primeiro passo da compacta√ß√£o √© percorrer todo o input e contar a frequ√™ncia de cada caractere, para isso utilizamos um vetor de tamanho 256 e para cada caractere usamos o √≠ndice ao convert√™-lo para inteiro como sua posi√ß√£o no vetor. Ent√£o, em cada posi√ß√£o do vetor com valor maior que zero significa que temos um caractere correspondente com frequ√™ncia igual a encontrada na posi√ß√£o. 
Assim, criamos um n√≥ para esse caractere e o adicionamos √† fila de prioridade. Ap√≥s possuirmos a fila de prioridade constru√≠mos a √°rvore utilizando o algoritmo de Huffman. Iremos precisar desta √°rvore para descompactar o arquivo ent√£o a registramos no cabe√ßalho do output atrav√©s de um caminhamento p√≥s-ordem. Cada n√≥ interno da √°rvore, e tamb√©m as quebras de linha, s√£o gravados como caracteres n√£o utilizados da tabela ASCII para facilitar na reconstru√ß√£o da √°rvore.
Com a √°rvore devidamente constru√≠da criamos ent√£o a tabela de codifica√ß√£o descrita na Se√ß√£o 2.2.2. Conseguimos assim, finalmente come√ßar efetivamente a compacta√ß√£o do arquivo. Percorremos todo o input e utilizando uma string como buffer para cada novo caractere gravamos no buffer o padr√£o encontrado na posi√ß√£o do caractere na tabela de codifica√ß√£o. Com o buffer reduzimos os chars dos 0‚Äôs e 1‚Äôs para bits e gravamos ent√£o no output o resultado. Ao fim, teremos no output o resultado da compacta√ß√£o.

2.2.4. Descompacta√ß√£o
A fun√ß√£o de descompacta√ß√£o tamb√©m recebe dois arquivos, o primeiro √© um arquivo anteriormente compactado pelo nosso programa e o segundo um .txt que receber√° o resultado da descompacta√ß√£o. 
O primeiro passo √© recuperar a √°rvore percorrendo o cabe√ßalho do arquivo. Fazemos isso utilizando uma pilha auxiliar. Assim, temos dois casos: Se o elemento for um caractere o empilhamos, se for um n√≥ interno (representado por um caractere n√£o utilizado da tabela ASCII) desempilhamos dois n√≥s, tornamos estes os filhos a esquerda e √† direita de um novo n√≥ e empilhamos novamente. Ao chegar no fim do cabe√ßalho teremos apenas um n√≥ na pilha que ser√° a raiz da √°rvore. 
Com a √°rvore constru√≠da conseguimos efetuar ent√£o a descompacta√ß√£o. Percorrendo nosso arquivo caminhamos na √°rvore para a direita ou para a esquerda ao ler respectivamente um 1 ou 0. Ao chegar em uma folha gravamos o caractere encontrado no arquivo de sa√≠da e voltamos a raiz da √°rvore. Ao terminarmos de percorrer todo o arquivo compactado teremos no arquivo de sa√≠da o nosso texto original.   


3. An√°lise de Complexidade
Neste t√≥pico iremos analisar a complexidade de tempo e de mem√≥ria dos passos do programa proposto.

3.1. Compacta√ß√£o
Como descrito na Se√ß√£o 2.2.3., o primeiro passo do programa √© percorrer todo o arquivo e montar a tabela de frequ√™ncia. Portanto, esse passo possui complexidade de tempo igual √† ùëÇ(n) e como o vetor possui tamanho fixo possui complexidade de espa√ßo igual √† O(256).
No pr√≥ximo passo, montamos a fila de prioridade. A inser√ß√£o possui um pior caso de O(n) quando precisamos inserir um n√≥ ao fim da fila. A remo√ß√£o possui complexidade O(1) pois sempre retiramos o primeiro elemento da fila. A complexidade de espa√ßo √© O(n) sendo n a quantidade de diferentes caracteres encontrados no texto.
Ao montar a √°rvore o algoritmo de Huffman sempre executa n-1 passos e para cada passo reinserimos um n√≥ na fila de prioridade. Ent√£o a complexidade para montar a √°rvore ser√° igual √† O(n^2) para o pior caso quando sempre que removermos os dois primeiros n√≥s da fila e os combinarmos o novo n√≥ seja inserido ao fim da fila. Como a fila usada √© a mesma do passo anterior temos a mesma complexidade de espa√ßo j√° que a fila nunca ir√° aumentar.
Para montar a tabela de codifica√ß√£o percorremos a √°rvore e sempre que encontramos uma folha inserimos o caminho feito √† matriz. Portanto, a complexidade de espa√ßo para percorrer toda a √°rvore √© ùëÇn. A complexidade de espa√ßo ser√° igual √† ùëÇ256‚ãÖh sendo 256 as linhas da matriz e h  a altura da √°rvore + 1.
Desta forma, o pior caso do programa possui complexidade de tempo O(n^2) e de espa√ßo O(n) o que sempre ir√° variar dependendo das caracter√≠sticas do texto a ser compactado como tamanho e quantidade de caracteres diferentes.

3.2. Descompacta√ß√£o
Para descompactarmos o arquivo, primeiro remontamos a √°rvore. Assim, percorremos o cabe√ßalho e executamos o algoritmo descrito na Se√ß√£o 2.2.4. Este algoritmo possui complexidade de tempo O(n) que √© o necess√°rio para percorrer todo o cabe√ßalho j√° que as opera√ß√µes de combina√ß√£o dos caracteres e n√≥s, desempilhar e empilhar possuem complexidade O(1). A complexidade de espa√ßo ser√° O(n) j√° que a pilha sempre possuir√° tamanho menor ou igual ao cabe√ßalho.
A descompacta√ß√£o efetivamente percorre todo o arquivo compactado e para cada bit caminha na √°rvore, ao encontrar uma folha grava o caractere no arquivo de sa√≠da e retorna ao in√≠cio da √°rvore. Portanto, complexidade de tempo O(n) e n√£o precisamos de nenhum espa√ßo adicional al√©m da √°rvore.


4. Estrat√©gias de Robustez
O programa possui somente tr√™s flags v√°lidas (-c, -d e ‚Äìh), qualquer op√ß√£o al√©m destas retorna um erro de op√ß√£o inv√°lida. 
Caso o usu√°rio n√£o forne√ßa arquivos suficientes √© retornado um erro de quantidade de argumentos inv√°lida. 
Caso n√£o seja poss√≠vel abrir algum arquivo √© retornado um erro informando que n√£o foi poss√≠vel abrir o arquivo.
Seria interessante verificar se o arquivo a ser descompactado foi um arquivo anteriormente compactado pelo programa, por exemplo verificando a extens√£o. N√£o implementei a funcionalidade pois o arquivo de sa√≠da deve ser fornecido pelo usu√°rio e n√£o tenho como controlar a sua extens√£o, ent√£o estou considerando que sempre ser√° um .txt. No entanto, isso abre uma brecha para o usu√°rio informar um arquivo qualquer para ser descompactado e quebrar o programa.


5. An√°lise Experimental
Para a an√°lise experimental escolhi analisar o tempo gasto para a compacta√ß√£o e descompacta√ß√£o variando o tamanho do arquivo de texto e a taxa de compress√£o m√©dia do programa.
Assim, foi testado a compress√£o e descompress√£o de arquivos de texto de tamanho em bytes de 100, 500, 1.000, 5.000, 10.000, 50.000 e 100.000. Dessa forma, obtemos os seguintes resultados em termos de tempo de execu√ß√£o:

Podemos ver com o gr√°fico um crescimento exponencial de ambas as opera√ß√µes do programa. Para a compress√£o isso era o esperado devido a sua complexidade assint√≥tica, no entanto a descompress√£o me surpreendeu devido a sua complexidade linear. Possivelmente o resultado inesperado se deve a manipula√ß√£o dos bin√°rios a qual n√£o tenho total compreens√£o, talvez com alguma corre√ß√£o nesta etapa a descompress√£o atinja crescimento linear.
A compress√£o m√©dia observada no programa foi de 43.33%. A taxa de compress√£o depende das caracter√≠sticas do arquivo de texto e pode variar de 20% a 90% [Cormen, 2022]. √â interessante destacar que devido a necessidade de armazenar a √°rvore no cabe√ßalho arquivos pequenos podem acabar ficando com tamanho maior ap√≥s passar pela compress√£o. Outra maneira de armazenar a √°rvore deveria ser estudada para contornar este problema.


6. Conclus√µes
O programa proposto consegue com sucesso compactar e descompactar arquivos de texto. 	A divis√£o dos passos do programa em etapas auxiliou na abstra√ß√£o do problema e melhor compreens√£o de como chegar ao resultado desejado.  
Al√©m disso, o programa pode obter um desempenho ainda melhor ao aprimorar a implementa√ß√£o da fila de prioridade, reduzindo a complexidade da inser√ß√£o de novos elementos. Ainda, outra forma de armazenar a √°rvore no cabe√ßalho do arquivo pode melhorar significativamente a taxa de compress√£o, especialmente para arquivos de texto pequenos.
Por fim, as taxas de compress√£o do programa variam de 20% a 90% a depender das caracter√≠sticas do arquivo de texto, como tamanho e quantidade de diferentes caracteres.


7. Bibliografia

Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Fourth Edition. MIT Press, 2022. ISBN 978-0-262-04630-5. Pages 431‚Äì439 of section 15.3: Huffman codes.

PROGRAME SEU FUTURO. Algoritmo de Huffman em C. YouTube, 28 de julho de 2021. Dispon√≠vel em:
< https://www.youtube.com/playlist?list=PLqJK4Oyr5WShtxF1Ch3Vq4b1Dzzb-WxbP >. Acesso em: 30 de junho de 2023.



Ap√™ndice A - Instru√ß√µes para Compila√ß√£o e Execu√ß√£o

Para compilar o arquivo primeiro descompacte o arquivo .zip e acesse a pasta raiz do projeto. Na pasta raiz execute o comando make para compilar. O execut√°vel ser√° armazenado na pasta bin com o nome programa.

Para executar o programa acesse diretamente o programa com ./bin/programa ou use o comando make run. 

O comando make run executa o programa com a flag -h que exibe as instru√ß√µes do programa. S√£o estas:
-c <arquivo a ser compactado> <arquivo compactado>
Compacta o primeiro arquivo e grava o resultado no segundo arquivo.
-d <arquivo compactado> <arquivo descompactado>
Descompacta o primeiro arquivo e grava o resultado no segundo arquivo.
-h
Exibe as instru√ß√µes do programa.

Exemplo de execu√ß√£o:
	./bin/programa -c test/input.txt test/binario.txt
	./bin/programa -d test/binario.txt test/output.txt

Instru√ß√µes adicionais do utilit√°rio makefile:
make clean - Deleta os arquivos .o e o execut√°vel.
make teste - Deleta os arquivos .o e o execut√°vel, em seguida, compila o programa novamente e o executa primeiro compilando o arquivo test/input.txt e depois descompactando o test/binario.txt em test/output.txt.

A pasta /test cont√©m tr√™s arquivos que podem ser utilizados para testar o programa atrav√©s do comando make teste. O arquivo input.txt cont√©m o texto a ser comprimido e pode ser alterado livremente. O arquivo binario.txt conter√° o resultado da compacta√ß√£o e output.txt conter√° o arquivo descompactado que ser√° id√™ntico a input.txt.